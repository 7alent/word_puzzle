
<div align="center">
  
# 《明日方舟》划词游戏1.0
  
_✨ 在汉字矩阵中尽可能地找到更多的干员技能名吧！ ✨_
  
</div>

<br/>

Hi，我是 [7alent](https://github.com/7alent) ，是一个Python小萌新，
这次应 [NumberSir](https://github.com/NumberSir) 之邀编写了这个小游戏，欢迎大家提出建议。<br/>

本游戏所用的数据answer.json为列表，其元素为干员技能名称。<br/>

本游戏代码可适用于其它划词游戏，只有语料库的不同，大家可以根据自己的需求将answer.json的内容换成成语、英语单词等。<br/>

欢迎大家查看我编写的其他项目，以及 [NumberSir](https://github.com/NumberSir) 的
[明日方舟小工具箱插件](https://github.com/NumberSir/nonebot_plugin_arktools) 。<br/>

如有转载，请附上本网址并告知我。<br/>

本说明更新时间为2023年5月22日。<br/>

<br/>


- [游戏规则](#游戏规则)
- [如何游玩](#如何游玩)
- [算法原理](#算法原理)


# 游戏规则
在汉字矩阵中找到干员的技能名称，找到的技能名称中任意两个相邻的字在矩阵中的位置也是相邻的。<br />

**相邻** 是指 **上下左右相邻** ，不包括斜对角。<br />

以下是一个简单的例子：<br />

|   剑   |   辉   |   星   |   回   |   手   |   骰   |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| **动** | **禁** | **锢** | **圣** | **之** | **掷** |
| **启** | **水** | **圣** | **全** | **巡** | **模** |
| **淋** | **定** | **拉** | **景** | **过** | **徒** |
| **淇** | **冰** | **特** | **摄** | **载** | **式** |
| **暴** | **式** | **兰** | **像** | **驱** | **量** |

由以上汉字矩阵能够找出的干员技能为 **拉特兰式冰淇淋**、**启动禁锢**、**全景过载摄像**、**星辉剑**、**掷骰**。<br />

查看详细规则的方法参见本说明的 **如何游玩** 章节。<br />


# 如何游玩

## 1. 选择难度或查看规则

游戏开始时，输入对应选项的数字序号来选择谜题的难度，或者查看详细规则。<br />

各个难度的具体介绍参见本说明的 **算法原理** 章节。<br />

|  1  |  2  |  3  |   4   |  5   |
|:---:|:---:|:---:|:-----:|:----:|
| 简单  | 中等  | 困难  | 自定义难度 | 查看规则 |

## 2. 查看提示或全部谜底

在一局游戏中，输入对应选项的数字序号来查看提示（可多次查看，提示不会重复），或者查看全部谜底。<br />

可使用的提示次数与谜底数量相同，使用完最后一次提示时会自动输出全部谜底。<br/>

|  1   |  2   |
|:----:|:----:|
| 查看提示 | 查看谜底 |

## 3. 继续游戏或者结束游戏

一局游戏的全部谜底揭示后，输入对应选项的数字序号来重新游玩（需要重新选择难度），或者退出游戏。<br />

|  1  |  2  |
|:---:|:---:|
| 继续  | 退出  |

## 4. 关于有效输入

游戏的各个选项需要输入 **数字** ，一般会给出输入数字的 **范围** 和 **类型** ，
常见的输入类型是 **整数** 和 **浮点数（小数）**。<br />

**范围** 一般会以 **闭区间** 的格式给出，例如 （6~10） 表示 可以输入 6，7，8，9，10 这几个整数。<br />

**类型** 中需要注意的是输入 **整数** 的情况，<u>不要给整数加小数点</u> 。<br/>

若输入有误，玩家将收到重新输入的说明，请各位玩家仔细阅读输入说明进行合适的输入。<br/>


# 算法原理
本游戏的算法主要分为 **寻路** 、 **填字** 、 **更新** 、 **补全** 四个步骤，具有一定随机性，算法中有多个参数供玩家进行调整，
从而实现谜题难度的自定义。<br/>

各步骤的执行顺序如下：<br/>

（1）若汉字矩阵中未填字的格子均不相邻，执行步骤（5）；否则，执行 **寻路** ；<br/>

（2）执行 **寻路** 后，执行 **填字** ；<br/>

（3）执行 **填字** 后，执行 **更新** ；<br/>

（4）执行 **更新** 后，跳回步骤（1）；<br/>

（5）最后执行 **补全** 。<br/>

## 1. 寻路

### 1.1 气矩阵

在将汉字填入矩阵之前，我们需要先找到一条路径，依次将汉字填入路径上的每个格子。<br/>

为了保证我们找到的路径足够长，我们的起点选择很重要，一个直观的想法是：找到一个周围比较“空”的起点 （在本说明中，“点”指的就是矩阵上的某个格子），
然后在选择路径的下一个的点（格子）时，我们也尽量选择周围比较“空”的格子。<br/>

唯一的问题是我们如何衡量一个格子的周围有多“空”。<br/>

一开始我们可能使用“上下左右相邻的空格子数量”来衡量某个格子周围有多“空”，我把这个办法得到的矩阵称为 **气矩阵** ，类比围棋里的“气”
（一个棋子上下左右相邻处未被其它棋子占据的交点数，这里的棋子和交点就类比汉字矩阵中的某个格子）。<br/>

气矩阵的第 i 行第 j 列元素表示汉字矩阵第 i 行第 j 列格子周围的空格子数量。

考虑未填字的汉字矩阵：<br/>

| &nbsp;&nbsp; | &nbsp;&nbsp; | &nbsp;&nbsp; | &nbsp;&nbsp; |
|:------------:|:------------:|:------------:|:------------:|
|    &nbsp;    |    &nbsp;    |    &nbsp;    |    &nbsp;    |
|    &nbsp;    |    &nbsp;    |    &nbsp;    |    &nbsp;    |
|    &nbsp;    |    &nbsp;    |    &nbsp;    |    &nbsp;    |

其气矩阵为：<br/>

|   2   |   3   |   3   |   2   |
|:-----:|:-----:|:-----:|:-----:|
| **3** | **4** | **4** | **3** |
| **3** | **4** | **4** | **3** |
| **2** | **3** | **3** | **2** |

<br/>

### 1.2 评分矩阵

然而经过测试，我发现气矩阵并不能满足寻路算法的需要，因为它只包含了某个格子上下左右四个位置的未填字格子数。<br/>

但很多时候我们需要保证选好路径上的一个格子之后，其周围的空格子数尽可能地多，即可以作为路径的下一个格子的选择尽可能地多。<br/>

换言之，我们不仅需要考虑到一个格子的周围的空旷程度（即它的周围有多“空”），更需要考虑到这个格子周围的格子的空旷程度。<br/>

这样的思路使得我们在更空旷的区域中去寻找路径，简言之，就是“哪块地方空我就先往哪里填字”。<br/>

为了更好地衡量“某个格子的周围的格子有多空”，我们的方法是构造 **评分矩阵** ，其第 i 行第 j 列元素为气矩阵的第 i 行第 j 列元素的周围八个格子
（<u>注意，不包括第 i 行第 j 列元素本身</u>） 的元素和。<br/>

在上述气矩阵例子中，其对应的评分矩阵为：<br/>

|   10   |   16   |   16   |   10   |
|:------:|:------:|:------:|:------:|
| **16** | **26** | **26** | **16** |
| **16** | **26** | **26** | **16** |
| **10** | **16** | **16** | **10** |

评分矩阵第 i 行第 j 列元素代表了汉字矩阵中第 i 行第 j 列格子的空旷程度评分，其评分越高，说明这个格子的周围就越“空”，
以这个格子为起点，能找到一条更长的路径的概率就越大（一般而言）。<br/>

<br/>

### 1.3 判别矩阵

为了更好地了解气矩阵和评分矩阵，我们引入 **判别矩阵** 。它是一个 **01矩阵** ，若其第 i 行第 j 列元素为1，
则表示汉字矩阵第 i 行第 j 列的格子未填入汉字，反之则表示此格子已填字。<br/>

在上述例子（未填字的汉字矩阵）中，其对应的判别矩阵为：<br/>

|   1   |   1   |   1   |   1   |
|:-----:|:-----:|:-----:|:-----:|
| **1** | **1** | **1** | **1** |
| **1** | **1** | **1** | **1** |
| **1** | **1** | **1** | **1** |

事实上，气矩阵是判别矩阵关于如下卷积核做3x3卷积后得到的结果：<br/>

|   0   |   1   |   0   |
|:-----:|:-----:|:-----:|
| **1** | **0** | **1** |
| **0** | **1** | **0** |

而评分矩阵则是气矩阵关于如下卷积核做3x3卷积后得到的结果。<br/>

|   1   |   1   |   1   |
|:-----:|:-----:|:-----:|
| **1** | **0** | **1** |
| **1** | **1** | **1** |

注意，<u>判别矩阵、气矩阵、评分矩阵的元素均不小于0</u>。<br/>

<br/>

### 1.4 随机生成路径

我们基于评分矩阵来随机生成一条路径，具体步骤如下：<br/>

（1）选择评分最高的格子作为起点，因为它的周围最“空”；注意起点的评分不为0，为0表示谜题已完成（详情参见步骤 **更新**）；
若评分最高的格子有多个，则依据等概率抽样从中随机抽取一个作为起点。<br/>

（2）若已选好路径上的一个格子，查看其周围是否有空格子，若无，则说明汉字矩阵中不存在相邻的空格子（路径至少需要两个格子构成），即所有的寻路工作已完成，
应当进行 **干扰字填充** 环节；若有，则跳到步骤（3）；<br/>

（3）设此格子周围的空格子的评分为c<sub>n</sub>（n为2或3或4），依一定的概率去选择下一个格子，评分为c<sub>n</sub>的格子被选为下一个格子的概率为
c<sub>n</sub>/c（c为所有相邻格子的评分之和），选好下一个格子后，跳到步骤（2）；<br/>

需要注意的是，以此法生成的路径是有向的，也就是说构成路径的格子有先后顺序，填字时要从起点开始依次填至终点。<br/>

借助于卷积，我们得以将一个格子周围更多格子的“空旷程度”信息考虑进来，这为我们的寻路算法提供了可靠性。<br/>

<br/>

## 2. 填字

找到一条路径后，我们需要将路径上的格子用汉字填满，这里的汉字既可能是 **技能名称** 或 **干扰字** 。<br/>

**填字** 分为 **抽取技能** 、 **打乱技能** 、 **插入干扰字** 、 **补全干扰字** 这四个步骤。<br/>

这四个步骤的先后顺序如下：<br>

（1）判断路径上未填字的格子数量，若为0，则填字已完成；若为1，则跳到步骤（5）；
若大于等于2，则执行 **抽取技能** ；<br/>

（2）执行 **抽取技能** 后，执行 **打乱技能** ；<br/>

（3）执行 **打乱技能** 后，执行 **插入干扰字** ；<br/>

（4）执行 **插入干扰字** 后，跳到步骤（1）；<br/>

（5）最后执行 **补全干扰字** 。<br/>

<br/>

### 2.1 抽取技能

从未抽取过的技能中抽出 <u>长度不大于路径上未填字格子数量的技能</u> ，且 **其长度至少为2** ，
也就是说我们 <u>不考虑长度为1的技能</u>（即“砰”）。<br/>

各个未抽取过的技能被抽到的概率是相同的。<br/>

<br/>

### 2.2 打乱技能

若抽取到的技能长度至少为3，它将有一定的概率被打乱，从而成为一串 **干扰字**（也就是不能成为谜底的、无意义的字）。<br/>

我们不打乱长度为2的技能，是因为打乱它们是没有意义的，打乱过后它们仍然是谜底。<br/>

例如：“掷骰”，打乱后变成“骰掷”，如果在矩阵中横向排列， 那么无论从左往右读还是从右往左读都是谜底，纵向排列的时候同理。<br/>

这涉及到 **详细规则** 中的一个细节：找谜底时不区分阅读方向， 从左往右/从右往左/从上往下/从下往上读都是允许的。<br/>

因此，对于长度不小于3的技能，我们在打乱它们时会 <u>排除 **全正序** 和 **全倒序** 的情况</u>，
 **全正序** 就是指技能原本的名字（即字的顺序没被打乱）， **全倒序** 指技能中的字按完全相反的顺序排列，如果倒过来读就是原本的顺序。<br/>

**打乱技能** 的具体操作是：生成一个0到1之间的均匀分布随机数（可能生成0或1），若其小于事先给定的 **阈值**（即 **打乱语句的概率** ），
则将技能打乱（技能不再为谜底），反之则不打乱（技能仍为谜底）。<br/>

无论抽取的技能是否被打乱，都将构成它的每个汉字依次填入路径的格子中（一个格子只能填一个汉字）。<br/>

<br/>

### 2.3 插入干扰字

每当一个（打乱后/未打乱）的技能被填入路径，随即按照一定的概率在未填字的格子中填入干扰字。<br/>

具体做法如下：依据事先给定的 **干扰字的最大长度** ，设其为 N ，则依据等概率抽样从整数 0，1，... ，N 的范围中随机抽出一个数，
设为 N<sup>'</sup> ，那么我们将随后插入 N<sup>'</sup> 个干扰字（ N<sup>'</sup>=0表示不插入干扰字）。<br/>

需要插入的每个干扰字将从技能名称中随机抽取（包括在 **抽取技能** 步骤中已抽取过和未抽取过的技能），每当我们需要填入一个干扰字，
我们先依据等概率抽样随机抽取一个技能，再依据等概率抽样随机抽取该技能中的一个字作为干扰字。<br/>

所以，干扰字是可能出现重复的。此外，干扰字恰巧构成一个谜底的概率几乎可以忽略，如果真的遇到了，
请截图反馈给 [7alent](https://github.com/7alent)（我） 或者 [NumberSir](https://github.com/NumberSir) 。<br/>

<br/>

### 2.4 补全干扰字

若路径上未填字的格子数量为1，则需要将这最后一个格子用干扰字填充，方法同步骤 **插入干扰字** ，
这两个步骤的名称不同只是为了区分它们在执行顺序上的不同。<br/>

<br/>

### 2.5 谜题难度参数

谜题的难度与 **谜题的行数** 、 **谜题的列数** 、 **干扰字的最大长度** 、 **打乱语句的概率** 有关。<br/>

**谜题的行数** 和 **谜题的列数** 越大，玩家需要阅读的汉字数量就越多，会加大谜题难度；<br/>

**干扰字的最大长度** 越大，对玩家造成的干扰和误导就越多，谜题难度也越高，其与步骤 **插入干扰字** 有关；<br/>

**打乱语句的概率** 越大，玩家越容易对打乱了顺序的技能名称产生错判，从而猜错谜底，因而难度也就越高，其与步骤 **打乱技能** 有关。<br/>

我们将 **谜题的行数** 和 **谜题的列数** 的取值范围规定为6、7、8、9、10这几个整数；<br/>

**干扰字的最大长度** 的取值范围为0、1、2、3、4、5这几个整数；<br/>

**打乱语句的概率** 的取值范围为0到1之间的浮点数（小数，包括0和1）。<br/>

玩家可在上述范围内对以上参数进行自定义，从而对难度进行调整，也可以选择我们预设的 **简单** 、 **中等** 、**困难** 三种难度，
其预设参数如下：<br/>

|    &nbsp;    | 简单  | 中等  | 困难  |
|:------------:|:---:|:---:|:---:|
|  **谜题的行数**   |  6  |  8  | 10  |
|  **谜题的列数**   |  6  |  8  | 10  |
| **干扰字的最大长度** |  2  |  3  |  4  |
| **打乱语句的概率**  | 0.1 | 0.3 | 0.5 |

<br/>

## 3. 更新

每当我们将一条路径上的格子用汉字填满，我们需要对判别矩阵进行更新，从而得到新的评分矩阵，并对评分矩阵进行 **修正** 。<br/>

我们将通过一个简单的例子来说明 **更新** 步骤的主要操作内容。<br/>

（1）首先将判别矩阵中填字的格子所在位置的元素由1改为0。<br/>

以如下判别矩阵为例：<br/>

|   1   |   1   |   1   |   1   |
|:-----:|:-----:|:-----:|:-----:|
| **1** | **1** | **1** | **1** |
| **1** | **1** | **1** | **1** |
| **1** | **1** | **1** | **1** |

我们在第2行第2列、第2行第3列、第3行第3列填入汉字，则判别矩阵更新为：<br/>

|   1   |   1   |   1   |   1   |
|:-----:|:-----:|:-----:|:-----:|
| **1** | **0** | **0** | **1** |
| **1** | **1** | **0** | **1** |
| **1** | **1** | **1** | **1** |

（2）随后，依据判别矩阵算出气矩阵。<br/>

在上例中，更新后的气矩阵为：<br/>

|   2   |   2   |   2   |   2   |
|:-----:|:-----:|:-----:|:-----:|
| **2** | **3** | **2** | **2** |
| **3** | **2** | **3** | **2** |
| **2** | **3** | **2** | **2** |

（3）然后，依据气矩阵算出评分矩阵。<br/>

在上例中，更新后的评分矩阵为：<br/>

|   7    |   11   |   11   |   6    |
|:------:|:------:|:------:|:------:|
| **12** | **18** | **18** | **11** |
| **12** | **20** | **18** | **11** |
| **8**  | **12** | **12** | **7**  |

（4）最后，对于判别矩阵中元素为0的位置，评分矩阵中相同的位置也要改成0。<br/>

此举将保证评分矩阵也能反映汉字矩阵的填字情况，同判别矩阵类似，若评分矩阵某位置元素为0，则汉字矩阵中该位置已填字，
该位置将不会成为路径起点（详情参见步骤 **寻路**）。<br/>

在上例中，修正后的评分矩阵为：<br/>

|   7    |   11   |   11   |   6    |
|:------:|:------:|:------:|:------:|
| **12** | **0**  | **0**  | **11** |
| **12** | **20** | **0**  | **11** |
| **8**  | **12** | **12** | **7**  |

另外值得一提的是，气矩阵并未 **修正** ，它只是我们由判别矩阵得到修正后评分矩阵的中间变量。<br/>

## 4. 补全

若汉字矩阵中未填字格子均不相邻，对这些格子用干扰字进行填充，方法同 **补全干扰字** 类似。

**补全** 步骤完成后，谜题已生成完毕。